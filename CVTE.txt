开始自我介绍：
一般根据项目提问
1.面向对象多态的实现
	1.c++的多态性就是通过晚绑定技术来实现的。
	2.在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数，如果对象类型是派生类，就调用派生类的函数，如果对象类型是基类，就调用基类的函数。
--------------------------------------------------------------------
2.c++设计模式
（01）――工厂模式:https://blog.csdn.net/wuzhekai1985/article/details/6660462
	1.简单工厂:
		1)主要特点:需要在工厂类中做判断，从而创造相应的产品。当增加新的产品时，就需要修改工厂类。
	2.工厂方法:
		1)定义一个用于创建对象的接口，让子类决定实例化哪一个类。Factory Method使一个类的实例化延迟到其子类。
	2.抽象工厂:
		1)提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
（02）――策略模式:https://blog.csdn.net/wuzhekai1985/article/details/6665197
	1.定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。
	2.本模式使得算法可独立于使用它的客户而变化。也就是说这些算法所完成的功能一样，对外的接口一样，只是各自实现上存在差异。
	3.用策略模式来封装算法，效果比较好。
（03）――适配器模式:https://blog.csdn.net/wuzhekai1985/article/details/6665542
	1.
（04）――单例模式:https://blog.csdn.net/wuzhekai1985/article/details/6665869
（05）――原型模式、模板方法模式（06）――建造者模式（07）――外观模式、组合模式（08）――代理模式（09）――享元模式（10）――桥接模式（11）――装饰模式（12）――备忘录模式（13）――中介者模式（14）――职责链模式（15）――观察者模式（16）――状态模式
--------------------------------------------------------------------
3.线程进程：https://www.cnblogs.com/Yogurshine/p/3640206.html
1.进程:
	进程是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。
	进程是一个具有独立功能的程序关于某个数据集合的一次运行活动。它可以申请和拥有系统资源，是一个动态的概念，是一个活动的实体。	
2.线程:
	轻量进程
	线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其它线程共享进程所拥有的全部资源。
3多线程:https://www.cnblogs.com/qtiger/p/5812483.html

	在单个程序中同时运行多个线程完成不同的工作，称为多线程。
	为了解决负载均衡问题,充分利用CPU资源.为了提高CPU的使用率,采用多线程的方式去同时完成几件事情而不互相干扰.为了处理大量的IO操作时或处理的情况需要花费大量的时间等等,比如:读写文件,视频图像的采集,处理,显示,保存等。
	优点：
		1.多线程技术使程序的响应速度更快 ,因为用户界面可以在进行其它工作的同时一直处于活动状态;
		2.当前没有进行处理的任务时可以将处理器时间让给其它任务;
		3.占用大量处理时间的任务可以定期将处理器时间让给其它任务;
		4.可以随时停止任务;
		5.可以分别设置各个任务的优先级以优化性；
		6.程序的运行效率可能会提高
	缺点：
		1.如果有大量的线程,会影响性能,因为操作系统需要在它们之间切换.
		2.更多的线程需要更多的内存空间
		3.线程中止需要考虑对程序运行的影响.
		4.通常块模型数据是在多个线程间共享的,需要防止线程死锁情况的发生

--------------------------------------------------------------------
4.内存管理，
堆和栈的区别：
	1.栈是由编译器在需要时分配的，不需要时自动清除的变量存储区。里面的变量通常是局部变量、函数参数等。堆是由malloc()函数（C++语言为 new 运算符）分配的内存块，内存释放由程序员手动控制，在 C 语言为 free 函数完成（C++中为 delete）。
	2.申请大小:
        	栈:在Windows下,栈是向低地址扩展的数据结构,是一块连续的内存区域.即栈顶的地址和栈的最大容量是系统预先规好的。栈的大小是1M,如果申请空间超过栈的剩余空间时,将提示overflow.因此,能从栈获得的空间较小。
		堆:堆是向高地址扩展的数据结构,是不连续的内存区域.这是因为系统是用链表来存储空闲内存地址的,自然是不连续的,而链表的遍历方向是由低地址向高地址.堆得大小受限于计算机系统中有效地虚拟内存.由此可见,堆获得的空间比较灵活,也比较大。
	3.栈是机器系统提供的数据结构,计算机会在底层对栈提供支持:分配专门的寄存器存放栈的地址,压栈出栈都有专门的指令执行,这就决定了栈的效率比较高。     
	4.堆则是C/C++函数库提供的,它的机制是很复杂的。
--------------------------------------------------------------------
5.进程线程的通信
进程的通信:
	1.进程间通信主要包括管道, 系统IPC（包括消息队列,信号,共享存储), 套接字(SOCKET).
		管道:
			1)普通管道PIPE, 通常有两种限制,一是单工,只能单向传输;二是只能在父子或者兄弟进程间使用.
			2)流管道s_pipe: 去除了第一种限制,为半双工，可以双向传输.
			3)命名管道:name_pipe, 去除了第二种限制,可以在许多并不相关的进程之间进行通讯.
		信号:
			（Signals ）是Unix系统中使用的最古老的进程间通信的方法之一。操作系统通过信号来通知进程系统中发生了某种预先规定好的事件（一组事件中的一个），它也是用户进程之间通信和同步的一种原始机制。
		系统V IPC:
			1)共享内存:
				不需要内核这个“代理人”，一般需要配合互斥锁和信号量来使用。
				共享内存是所有进程间通信方式中效率最高(原因是采用指针操作，直接访问地址)
			2)消息队列:
				消息队列就是消息的一个链表，它允许一个或多个进程向它写消息，一个或多个进程从中读消息。Linux维护了一个消息队列向量表：msgque，来表示系统中所有的消息队列。
				消息是按照队列一样排队的，先进先出FIFO
                      		当你接收的消息类型没有的时候，会阻塞当前进程
			3)信号量（旗语）:
				通过对进程拥有信号量资源的pv操作去控制多个进程对于临界区资源的访问保证(通过阻塞其他进程)两个或多个关键代码段(临界区资源)不被并发调用

--------------------------------------------------------------------
6.ARM中断处理

	1)当中断产生后，除了复位中断立即中止当前指令外，其余情况都是处理器完成当前指令后，才去执行异常处理程序。
	2)CPSR（程序状态寄存器）--> SPSR（程序状态保存寄存器）
	3)设置当前状态寄存器CPSR的相应位。设置CPSR中的M4~M0的5位，进入相应工作模式，设置I=1禁止IRQ中断，如果进入复位模式或FIQ模式，还要设置F=1以禁止FIQ中断。
	4)将引起异常指令的下一条地址（断点地址）保存到新异常工作模式的LR（R14）中，使异常处理程序执行完后正确返回原来程序处继续向下执行。

	5)首先恢复原来被保护的用户寄存器。
	6)将SPSR寄存器复制到CPSR中，使得原来CPSR状态从相应的SOSR中恢复，一恢复被中断的程序状态。
	7)根据异常类型将PC值恢复成断点地址，以继续执行用户原来运行着的程序。

注意：	（1）程序状态寄存器及断点地址的恢复必须同时进行。

	（2）由于异常随机发生，所以要对异常向量进行初始化，即在异常向量的地址处放置一条跳转指令，跳转到异常处理程序

ARM处理器共有37个寄存器,Cortex体系有40个寄存器


ARM9采用哈佛体系结构，指令和数据分属不同的总线，可以并行处理。在流水线上，ARM7是三级流水线，ARM9是五级流水线。


ARM处理器7种工作模式：
	用户模式（USR）：正常程序执行模式，不能直接切换到其他模式
	系统模式（SYS）：运行操作系统的特权任务，与用户模式类似，但具有可以直接切换到其他模式等特权
	快中断模式（FIQ）：支持高速数据传输及通道处理，FIQ异常响应时进入此模式
	中断模式（IRQ）：用于通用中断处理，IRQ异常响应时进入此模式
	管理模式（SVC）：操作系统保护模式，系统复位和软件中断响应时进入此模式（由系统调用执行软中断SWI命令触发）
	中止模式（ABT）：用于支持虚拟内存和/或存储器保护，在ARM7TDMI没有大用处
	未定义模式（UND）：支持硬件协处理器的软件仿真，未定义指令异常响应时进入此模式

	除用户模式外，其余6种工作模式都属于特权模式

    	特权模式中除了系统模式以外的其余5种模式称为异常模式

    	大多数程序运行于用户模式

    	进入特权模式是为了处理中断、异常、或者访问被保护的系统资源

    硬件权限级别：系统模式 > 异常模式 > 用户模式
--------------------------------------------------------------------
7.Linux有什么看法？
	(1)基本思想：第一，一切都是文件；第二，每个软件都有确定的用途。
	(2)完全免费,吸收了无数程序员的精华，不断壮大。
	(3)完全兼容POSIX1.0标准
	(4)多用户、多任务
	(5)具有字符界面和图形界面。
	(6)支持多种平台
	(7)LFS 
	(8)
	(9)
--------------------------------------------------------------------
8.字符串拷贝函数

_strcpy(char * dest, const char * src)
{
    char *p=dest;
    while(*dest++ = *src++);
    dest=p;
}

--------------------------------------------------------------------
9.写个快速排序或者堆排序
void qSort(int *a,int p,int q){
    if(p >= q) return;
    int i = p;
    for(int j = p; j < q ; j++)
    {
        if(a[j] < a[q])
        {
            if(i != j)
                swap(a[i],a[j]);
            i++;
        }
    }
    swap(a[i],a[q]);
    qSort(a,p,i-1);
    qSort(a,i+1,q);

}
--------------------------------------------------------------------
10.你认为嵌入式软件工程师应该做什么？流程？
*********************************************
	嵌入式系统是以应用为中心，以计算机技术为基础，并且软硬件可裁剪，适用于应用系统对功能、可靠性、成本、体积、功耗有严格要求的专用计算机系统。它一般由嵌入式微处理器、外围硬件设备、嵌入式操作系统以及用户的应用程序等四个部分组成，用于实现对其他设备的控制、监视或管理等功能。
	嵌入式软件工程师主要从事嵌入式软件开发工作。涉及应用层以及底层软件开发和设计工作		。
*********************************************
--------------------------------------------------------------------
11.嵌入式系统的特点?
	(1)与应用紧密结合的，它具有很强的专用性
	(2)系统内核小,系统精简。
	(3)高实时性的系统软件
	(4)具有较长的生命周期。
	(5)程序固化
	()

	嵌入式系统通常执行的是带有特定要求的预先定义的任务。
	国内普遍认同的嵌入式系统定义为：以应用为中心，以计算机技术为基础，软硬件可裁剪，适应应用系统对功能、可靠性、成本、体积、功耗等严格要求的专用计算机系统。
	
--------------------------------------------------------------------
12.五年内有什么规划？
	1、成为一名顶尖的嵌入式工程师，实现自己的中国梦。
	2、了解IT行业，互联网行业是如何运作的。比如，一个APP的背后隐含了多少的东西。
	3、人不可能一直工作：做一些没做过的事情。
--------------------------------------------------------------------
13.一些项目实现
--------------------------------------------------------------------
14.最后怎么解决项目遇到的问题。
大体框架：
模块化：
内存泄漏；
打印；
--------------------------------------------------------------------


面试题目
1.自我介绍
大一，大二，大三，未来
--------------------------------------------------------------------
2.做过哪些项目
--------------------------------------------------------------------
3.详细介绍一个项目
--------------------------------------------------------------------
4.什么是引用
	1)引用仅是变量的别名，而不是实实在在地定义了一个变量，因此引用本身并不占用内存，而是和目标变量共同指向目标变量的内存地址.

 	2）表达式中的取地址符&不再是取变量的地址，而是用来表示该变量是引用类型的变量。

 	3)定义一个引用时，必须对其初始化。

	4)用引用返回一个函数值的最大好处是，在内存中不产生被返回值的副本。

--------------------------------------------------------------------
5.指针和引用的区别
	(1)指针：指针是一个变量，只不过这个变量存储的是一个地址，指向内存的一个存储单元；而引用跟原来的变量实质上是同一个东西，只不过是原变量的一个别名而已。

	(2)引用不可以为空，当被创建的时候，必须初始化，而指针可以是空值，可以在任何时候被初始化。
	
	(3)可以有const指针，但是没有const引用；即指针存在指向常量的指针const int *p和常量指针int *const p，而引用只存在常量引用int const &a，不存在引用常量int& const a。

	(4)指针可以有多级，但是引用只能是一级（int **p；合法 而 int &&a是不合法的）	
	
	(5)指针的值可以为空，但是引用的值不能为NULL，并且引用在定义的时候必须初始化；

	(6)指针的值在初始化后可以改变，即指向其它的存储单元，而引用在进行初始化后就不会再改变了。

	(7)”sizeof引用”得到的是所指向的变量(对象)的大小，而”sizeof指针”得到的是指针本身的大小；

	(8)指针和引用的自增(++)运算意义不一样；

	(9)如果返回动态内存分配的对象或者内存，必须使用指针，引用可能引起内存泄漏；
--------------------------------------------------------------------
6.详细解释TCP(第四层传输层)
	应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，然后TCP把数据流分区成适当长度的报文段（通常受该计算机连接的网络的数据链路层的最大传输单元（MTU）的限制）。之后TCP把结果包传给IP层，由它来通过网络将包传送给接收端实体[1]的TCP层。
	TCP为了保证不发生丢包，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的包发回一个相应的确认（ACK）；
	如果发送端实体在合理的往返时延（RTT）内未收到确认，那么对应的数据包就被假设为已丢失将会被进行重传。

	在数据正确性与合法性上，TCP用一个校验和函数来检验数据是否有错误，在发送和接收时都要计算校验和；同时可以使用md5认证对数据进行加密。
	在保证可靠性上，采用超时重传和捎带确认机制。
	在流量控制上，采用滑动窗口协议，协议中规定，对于窗口内未经确认的分组需要重传。

	连接建立（三从握手）
	连接终止（四次握手）
--------------------------------------------------------------------
7.数组和指针的区别
	(1)数组就是存放一定数量变量的地址连续的内存空间
	(2)在作为函数传递参数的时候，数组是等同于指针的
	(3)在使用下标的时候，二者的用法相同。都是原地址加上下标的值，不过数组的原地址就是数组首元素的地址是固定的，指针的原地址就不是固定的，指针指向那个元素，该元素的地址就是要加上下标之前的原地址，因为这样，这样指针的灵活性很大。
--------------------------------------------------------------------
8.怎么在LINUX下运行一个执行文件
./
--------------------------------------------------------------------
9.有哪几种方法创建一个文件
普通文件：
$ touch regular
目录：
$ mkdir directory
符号链接：
$ ln -s ./regular symbolic
FIFO:
$ mknod fifo p
字符特殊文件：
# mknod character c 1 1
块特殊文件：
# mknod block b 1 2
socket文件：
$ mksock sock
如果没有mksock命令，使用nc命令进行创建：
$ nc -UI ./sock
--------------------------------------------------------------------
10.内核空间和用户空间的区别，内核空间多大(1 GB)
	1)每个进程有各自的私有用户空间（0～3G），这个空间对系统中的其他进程是不可见的,而内核空间则为所有进程以及内核所共享。
	2)Linux使用两级保护机制：0级供内核使用，3级供用户程序使用。

	3)用户态切换到内核态的3种方式:

		a. 系统调用

		这是用户态进程主动要求切换到内核态的一种方式，用户态进程通过系统调用申请使用操作系统提供的服务程序完成工作，比如fork()实际上就是执行了一个创建新进程的系统调用。而系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。

		b. 异常

		当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，这时会触发由当前运行进程切换到处理此异常的内核相关程序中，也就转到了内核态，比如缺页异常。

		c. 外围设备的中断

		当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会暂停执行下一条即将要执行的指令转而去执行与中断信号对应的处理程序，如果先前执行的指令是用户态下的程序，那么这个转换的过程自然也就发生了由用户态到内核态的切换。比如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后续操作等。

		这3种方式是系统在运行时由用户态转到内核态的最主要方式，其中系统调用可以认为是用户进程主动发起的，异常和外围设备中断则是被动的。
--------------------------------------------------------------------
11.用户权限，更改权限
sudo -s
--------------------------------------------------------------------
13.手写一道编程题（解析字符串）
--------------------------------------------------------------------
14.中断处理函数流程

--------------------------------------------------------------------
15.知不知道这个职位做什么
16.能否接受出差，是否接受海外出差
17.觉得自己有哪些方面没表现出来
18.有什么问题想问
	1、嵌入式工程师很多时候是在编程（跟软件打交道）吗？
	2、嵌入式工程师需要了解哪些硬件知识
	3、顶尖的嵌入式工程师需要必备什么技能